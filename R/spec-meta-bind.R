# Generated by helper-dev.R, do not edit by hand

spec_meta_bind <- list(
  bind_return_value = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      expect_identical(res, bind_res$value)
      expect_false(bind_res$visible)
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_return_value_statement = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      data <- data.frame(a = rep(1:5, 1:5))
      data$b <- seq_along(data$a)
      table_name <- random_table_name()
      dbWriteTable(con, table_name, data, temporary = TRUE)
      value_names <- letters[seq_along(bind_values)]
      placeholder <- placeholder_fun(length(bind_values))
      sql <- paste0("UPDATE ", dbQuoteIdentifier(con, table_name), " SET b = b + 1 WHERE ", paste(value_names, " = ", placeholder, collapse = " AND "))
      res <- dbSendStatement(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_identical(dbGetRowsAffected(res), NA_integer_)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      expect_identical(res, bind_res$value)
      expect_false(bind_res$visible)
      rows_affected <- dbGetRowsAffected(res)
      if (!isTRUE(allow_na_rows_affected) || !is.na(rows_affected)) {
        expect_equal(rows_affected, sum(bind_values[[1]]))
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_too_many = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- if (is.null(names(bind_values))) {
        c(bind_values, bind_values[[1L]])
      } else {
        c(bind_values, bogus = bind_values[[1L]])
      }
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_not_enough = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values[-1L]
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_wrong_name = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = TRUE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- stats::setNames(bind_values, paste0("bogus", names(bind_values)))
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_multi_row_unequal_length = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(1:3, 2:4)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- {
        bind_values[[2]] <- bind_values[[2]][-1]
        bind_values
      }
      data <- data.frame(a = rep(1:5, 1:5))
      data$b <- seq_along(data$a)
      table_name <- random_table_name()
      dbWriteTable(con, table_name, data, temporary = TRUE)
      value_names <- letters[seq_along(bind_values)]
      placeholder <- placeholder_fun(length(bind_values))
      sql <- paste0("UPDATE ", dbQuoteIdentifier(con, table_name), " SET b = b + 1 WHERE ", paste(value_names, " = ", placeholder, collapse = " AND "))
      res <- dbSendStatement(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_identical(dbGetRowsAffected(res), NA_integer_)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_named_param_unnamed_placeholders = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = TRUE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- stats::setNames(bind_values, NULL)
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_named_param_empty_placeholders = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = TRUE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(1L, 2L)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- {
        names(bind_values)[[1]] <- ""
        bind_values
      }
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_named_param_na_placeholders = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = TRUE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(1L, 2L)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- {
        names(bind_values)[[1]] <- NA
        bind_values
      }
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_unnamed_param_named_placeholders = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = FALSE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- stats::setNames(bind_values, letters[seq_along(bind_values)])
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_premature_clear = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      dbClearResult(res)
      expect_error(withVisible(dbBind(res, bind_values_patched)), ".*")
    }
  },
  bind_multi_row = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(1:3)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_multi_row_zero_length = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(integer(0), integer(0))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_multi_row_statement = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(1:3)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      data <- data.frame(a = rep(1:5, 1:5))
      data$b <- seq_along(data$a)
      table_name <- random_table_name()
      dbWriteTable(con, table_name, data, temporary = TRUE)
      value_names <- letters[seq_along(bind_values)]
      placeholder <- placeholder_fun(length(bind_values))
      sql <- paste0("UPDATE ", dbQuoteIdentifier(con, table_name), " SET b = b + 1 WHERE ", paste(value_names, " = ", placeholder, collapse = " AND "))
      res <- dbSendStatement(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_identical(dbGetRowsAffected(res), NA_integer_)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows_affected <- dbGetRowsAffected(res)
      if (!isTRUE(allow_na_rows_affected) || !is.na(rows_affected)) {
        expect_equal(rows_affected, sum(bind_values[[1]]))
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_repeated = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_repeated_statement = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      data <- data.frame(a = rep(1:5, 1:5))
      data$b <- seq_along(data$a)
      table_name <- random_table_name()
      dbWriteTable(con, table_name, data, temporary = TRUE)
      value_names <- letters[seq_along(bind_values)]
      placeholder <- placeholder_fun(length(bind_values))
      sql <- paste0("UPDATE ", dbQuoteIdentifier(con, table_name), " SET b = b + 1 WHERE ", paste(value_names, " = ", placeholder, collapse = " AND "))
      res <- dbSendStatement(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_identical(dbGetRowsAffected(res), NA_integer_)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows_affected <- dbGetRowsAffected(res)
      if (!isTRUE(allow_na_rows_affected) || !is.na(rows_affected)) {
        expect_equal(rows_affected, sum(bind_values[[1]]))
      }
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows_affected <- dbGetRowsAffected(res)
      if (!isTRUE(allow_na_rows_affected) || !is.na(rows_affected)) {
        expect_equal(rows_affected, sum(bind_values[[1]]))
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_repeated_untouched = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_repeated_untouched_statement = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- 1L
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      data <- data.frame(a = rep(1:5, 1:5))
      data$b <- seq_along(data$a)
      table_name <- random_table_name()
      dbWriteTable(con, table_name, data, temporary = TRUE)
      value_names <- letters[seq_along(bind_values)]
      placeholder <- placeholder_fun(length(bind_values))
      sql <- paste0("UPDATE ", dbQuoteIdentifier(con, table_name), " SET b = b + 1 WHERE ", paste(value_names, " = ", placeholder, collapse = " AND "))
      res <- dbSendStatement(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_identical(dbGetRowsAffected(res), NA_integer_)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows_affected <- dbGetRowsAffected(res)
      if (!isTRUE(allow_na_rows_affected) || !is.na(rows_affected)) {
        expect_equal(rows_affected, sum(bind_values[[1]]))
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_named_param_shuffle = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx, requires_names = TRUE)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c(1.5, 2.5, 3.5, NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values[c(3, 1, 2, 4)]
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_integer = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c(1L, 2L, 3L, NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_numeric = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c(1.5, 2.5, 3.5, NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_logical = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c(TRUE, FALSE, NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_character = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c("\U{41A}\U{438}\U{440}\U{438}\U{43B}\U{43B}", "M\U{FC}ller", "M\U{FC}ller", "\U{6211}\U{662F}\U{8C01}", "ASCII", NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_character_escape = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- c(" ", "\n", "\r", "\b", "'", "\"", "[", "]", r"[\]", NA)
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_factor = function(ctx, con) {
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(factor("\U{41A}\U{438}\U{440}\U{438}\U{43B}\U{43B}"), factor("M\U{FC}ller"), factor("M\U{FC}ller"), factor("\U{6211}\U{662F}\U{8C01}"), factor("ASCII"), factor(NA_character_))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(suppressWarnings(expect_warning(dbBind(res, bind_values_patched))))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_date = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$date_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- as.Date(c("2023-12-17", "2023-12-18", "2023-12-19", NA))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_date_integer = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$date_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- structure(c(18618L, 18619L, 18620L, NA), class = "Date")
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_timestamp = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$timestamp_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- as.POSIXct(c("2023-12-17 02:40:22", "2023-12-17 02:40:23", "2023-12-17 02:40:24", NA))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_timestamp_lt = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$timestamp_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(structure(as.POSIXlt(as.POSIXct("2023-12-17 02:40:49")), balanced = TRUE), structure(as.POSIXlt(as.POSIXct("2023-12-17 02:40:50")), balanced = TRUE), structure(as.POSIXlt(as.POSIXct("2023-12-17 02:40:51")), balanced = TRUE), structure(as.POSIXlt(NA_character_), balanced = TRUE))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_time_seconds = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$time_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- structure(c(1, 2, 3, NA), class = "difftime", units = "secs")
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_time_hours = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$time_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- structure(c(1, 2, 3, NA), class = "difftime", units = "hours")
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_time_minutes_integer = function(ctx, con) {
    skip_if(!isTRUE(ctx$tweaks$time_typed))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- identity
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- structure(c(1, 2, 3, NA), class = "difftime", units = "mins")
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_raw = function(ctx, con) {
    skip_if(isTRUE(ctx$tweaks$omit_blob_tests))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- ctx$tweaks$blob_cast
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(list(as.raw(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10))), list(raw(3)), list(NULL))
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  bind_blob = function(ctx, con) {
    skip_if(isTRUE(ctx$tweaks$omit_blob_tests))
    placeholder_funs <- get_placeholder_funs(ctx)
    is_null_check <- ctx$tweaks$is_null_check
    cast_fun <- ctx$tweaks$blob_cast
    allow_na_rows_affected <- ctx$tweaks$allow_na_rows_affected
    for (placeholder_fun in placeholder_funs) {
      bind_values <- list(
        structure(vctrs::list_of(as.raw(c(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)), .ptype = raw(0)), class = c("blob", "vctrs_list_of", "vctrs_vctr", "list")),
        structure(vctrs::list_of(raw(3), .ptype = raw(0)), class = c("blob", "vctrs_list_of", "vctrs_vctr", "list")),
        structure(vctrs::list_of(NULL, .ptype = raw(0)), class = c("blob", "vctrs_list_of", "vctrs_vctr", "list"))
      )
      if (!is.null(names(placeholder_fun(1)))) {
        names(bind_values) <- names(placeholder_fun(length(bind_values)))
      }
      bind_values_patched <- bind_values
      placeholder <- placeholder_fun(length(bind_values))
      is_na <- vapply(bind_values, is_na_or_null, logical(1))
      placeholder_values <- vapply(bind_values, function(x) DBI::dbQuoteLiteral(con, x[1]), character(1))
      result_check <- ifelse(is_na, paste0("(", is_null_check(cast_fun(placeholder)), ")"), paste0("(", cast_fun(placeholder), " = ", placeholder_values, ")"))
      result_names <- letters[seq_along(bind_values)]
      sql <- paste0(
        "SELECT ",
        paste0("CASE WHEN ", result_check, " THEN 1.5 ELSE 2.5 END AS ", result_names, collapse = ", ")
      )
      res <- dbSendQuery(con, sql)
      on.exit(if (!is.null(res)) expect_error(dbClearResult(res), NA))
      expect_error(dbFetch(res))
      expect_equal(dbGetRowCount(res), 0)
      expect_true(dbIsValid(res))
      expect_false(dbHasCompleted(res))
      bind_res <- withVisible(dbBind(res, bind_values_patched))
      rows <- check_df(dbFetch(res))
      expect_equal(nrow(rows), length(bind_values[[1]]))
      if (nrow(rows) > 0) {
        result_names <- letters[seq_along(bind_values)]
        expected <- c(1.5, rep(2.5, nrow(rows) - 1))
        all_expected <- rep(list(expected), length(bind_values))
        result <- as.data.frame(setNames(all_expected, result_names))
        expect_equal(rows, result)
      }
      expect_error(dbClearResult(res), NA)
      res <- NULL
    }
  },
  NULL
)
